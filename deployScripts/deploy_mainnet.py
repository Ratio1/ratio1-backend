from os import environ
from naeural_client import Session, PLUGIN_SIGNATURES


if __name__ == "__main__":
  session = Session()

  nodes = [
    "0xai_example-1234"
  ]

  if isinstance(nodes, str):
    nodes = [nodes]

  for node in nodes:
    session.wait_for_node(node)

  # In case this is not provided and create_and_deploy_balanced_web_app is used an exception will be raised.
  # In case this is not provided by the user, but create_webapp method is used, a unique URL will be generated by the ngrok service.
  # Warning! create_webapp method does not support multiple nodes.
  ngrok_edge_label = "" 

  # Defining the environment variables for the webapp.
  port = 5000
  env_vars = {
    'APP_PORT': port,

    'DATABASE_PASSWORD':'',
    'DATABASE_HOST':'',
    'DATABASE_PORT':'',
    'DATABASE_USER':'',
    'DATABASE_NAME':'',
    
    'JWT_KEYSEED_HEX':'',
    'JWT_SECRET':'',
    'JWT_CONFIRM_SECRET':'',

    'MAIL_API_KEY':'',
    
    'SUMSUB_APP_TOKEN':'',
    'SUMSUB_SECRET_KEY':'',
    'SUMSUB_JWT_SECRET_KEY':'',

    'MAILERLITE_GROUP_ID':'',
    'MAILERLITE_API_KEY':'',

    'OBLIO_CLIENT_SECRET':'',
    'OBLIO_EVENT_SIGNATURE': 'LicensesCreated(address,bytes32,uint256,uint256,uint256)',

    'INFURA_SECRET':'',

    'EMAIL_TEMPLATES_PATH':'./templates/html/',
  }

  # Defining the assets of the application.
  assets = {
    'operation': "clone",
    "url": "https://github.com/NaeuralEdgeProtocol/ratio1-backend",
    "username":"",
    "token":""
  }

  # Defining the webapp run commands.
  run_command = "./cmd/cmd"

  # instance: PLUGIN_TYPES.CUSTOM_WEBAPI_01
  session.create_and_deploy_balanced_web_app(
    nodes=nodes,
    name="kyc_backend_instance",
    signature=PLUGIN_SIGNATURES.GENERIC_WEB_APP,
    env_vars=env_vars,
    port=port,
    run_command=run_command,
    ngrok_edge_label=ngrok_edge_label,
    assets=assets
  )

  # Observation:
  #   next code is not mandatory - it is used to keep the session open and cleanup the resources
  #   in production, you would not need this code as the script can close after the pipeline will be sent
  session.run(
    wait=True,  # wait for the user to stop the execution
    close_pipelines=False  # when the user stops the execution, the remote edge-node pipelines will be closed
  )